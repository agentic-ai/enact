# enact - A Framework for Generative Software.

## Introduction

TODO: Intro, core features.

## Why enact?

With the rise of generative AI models, we are witnessing a subtle but
significant shift in how we conceptualize and build software.

Traditional software relies on functional buildings blocks in which inputs and
system state directly determine outputs. In contrast, modern AI-powered software
utilizes generative elements, in which each input is associated with a range of
possible outputs.

This seemingly small pivot from deterministic functions to conditional
distributions has far-reaching implications, a few of which are summarized in
the table below:

|        |  Traditional  |  Generative  |
| :----: | :-----------: | :----------: |
| Building block | Deterministic functions | Conditional distributions |
| Goal | Add features, squash bugs | Improve output distribution |
| Subsystems | Interchangeable | Unique |
| Executions | Logged for metrics/debugging | Training data |
| Interactivity | At system boundaries | Within system components |
| Code sharing | Frameworks | Components |
| Code vs data | Distinct | Overlapping |


### Adequate output distributions

We could define the goal of traditional software engineering as producing
systems that are feature-complete and bug-free. This summary inadequately
describes the case of generative software, since a significant portion of
engineering effort is aimed at improving quality metrics on the output
distribution. Correctness is no longer merely a matter of ensuring that
individual outputs match some correctness specification, but that the
distribution as a whole does. For example, in a chatbot one may want to balance
average helpfulness and factual accuracy of responses while heavily penalizing
outputs that are rude or unhinged.

### Components are unique

In traditional software engineering, the choice between two API-identical
implementations primarily revolves around practicalities such as performance or
maintainability. However, in generative software, individual components produce
distributions that may be more or less well-fitted to the system's overall goal.
For example, two text-to-image generators may have identical APIs, but their
relative suitability may vary depending on the application domain.

### Executions are data

In a conventional software, executions are generally tracked at a low level
of resolution, since their primary use is to track metrics and debug errors. In
generative software, executions provide valuable information about the
distributions being sampled and may be used for training: Outputs can be
reviewed to produce data for fine-tuning, data from one generative model can be
distilled into another and whole executions may directly feed back into
generative components (as is the case in of 'self-healing' programs).

### Humans are in the loop

Unlike traditional systems, where user interactions happen at system boundaries,
AI and humans are equal participants in generative computations. An example is RLHF
(Reinforcement Learning from Human Feedback), where humans provide feedback on AI
output, only to be replaced by an AI model that mimics their feedback behavior
during the training process. Critical generative flows (e.g., the drafting
of legal documents) may require a human verification step.

The choice between sampling human input and sampling a generative model will be
one of cost, quality and timing constraints, and may be subject to change during
the development of a system.

### Collaborative evolution

Generative AI naturally lends itself to collaboration and sharing, as evidenced
by the large number of user-trained open source models, e.g., in the domain of
text-to-image models. Where traditionally, code sharing concentrates on
open-source frameworks whose features aggregate common user needs, collaboration
in generative AI lends itself to a more evolutionary style, where foundation
models that aggregate broad functionality coexist with user modifications that
specialize models into target niches.

### Data is code, code is data

Traditional software systems tend to allow a clear distinction between code
(written by developers) and data (generated by the user and the system). In
generative systems this distinction breaks down: Approaches such as AutoGPT or
Voyager use generative AI to generate programs (specified in code or plain
text), which in turn may be interpreted by generative AI systems; prompts for
chat-based generative AI could be considered both code or data.

## Installation

## Quick start

## Usage / Examples

## API Reference

## Contributing



